## PyLadies Intermediate Python class, 20141017

1. Review of loops: `for`, `while`. 

  2. Sample `for`-loop.

        ```python
        In [1]: lst = []
        
        In [2]: for i in range(10):
           ...:     lst.append(i)
           ...:     
        
        In [3]: print(lst)
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        ```

  2. Replacing a loop with a comprehension: 

    3. list-comprehensions. Syntax:

        ```python
        In [4]: lst = [i for i in range(10)]
        
        In [5]: print(lst)
        Out[5]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        ```

    3. set-comprehensions

        ```python
        In [6]: s = {i for i in range(10)}
        
        In [7]: s
        Out[7]: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
        ```

    3. dict-comprehensions

        ```python
        In [11]: d = {i: i ** 2 for i in range(10)}
        
        In [12]: print(d)
        {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
        ```

      Further: use `zip(list1, list2)` to draw keys and values from different lists:

        ```python
        In [13]: d2 = {i: j for i,j in zip(['a', 'b', 'c'], [1, 2, 3])}
        
        In [14]: print(d2)
        {'c': 3, 'a': 1, 'b': 2}
        ```

  2. Nesting

    3. nested loops

        ```python
        In [15]: lst = []
        
        In [16]: letters = ['a', 'b', 'c']
        
        In [17]: numbers = [1, 2, 3]
        
        In [18]: for i in numbers:
        ....:     for j in letters:
        ....:         lst.append((i, j))
        ....:         
        
        In [19]: print(lst)
        [(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]
        ```

    3. nested comprehensions

        ```python
        In [20]: lst = [(i, j) for i in numbers for j in letters]
        
        In [21]: print(lst)
        [(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]
        ```

      Notice the structure of the nested comprehension: `[... <outer for expression> <inner for expression>]`.

  2. Filtering

    3. `if`-blocks and `continue` within a loop

        ```python
        In [22]: lst = []
        
        In [23]: for i in range(25):
        ....:       if i % 6:
        ....:           continue
        ....:       else:
        ....:           lst.append(i)
        ....:      
        
        In [24]: print(lst)
        [0, 6, 12, 18, 24]

        ```

    3. Filtering within a comprehension
    
      4. Filtering with `if`: Syntax: `[... <for expression> <if expression>]`.

        ```python
        In [25]: lst = [i for i in range(25) if not i % 6]
        
        In [26]: print(lst)
        [0, 6, 12, 18, 24]
        ```

      4. Filtering with `if-else`: Syntax: `[... <if-else expression> <for expression>]` (notice the difference).
      
        ```python
        In [27]: lst1 = []
        
        In [28]: for i in range(10):
        ....:        if i % 3:
        ....:            lst1.append(i)
        ....:        else:
        ....:            lst1.append(i ** 2)
        ....:      
        
        In [29]: print(lst1)
        [0, 1, 2, 9, 4, 5, 36, 7, 8, 81]
        
        In [30]: lst2 = [i if i % 3 else i ** 2 for i in range(10)]
        
        In [31]: print(lst2)
        [0, 1, 2, 9, 4, 5, 36, 7, 8, 81]
        
        In [32]: lst1 == lst2
        Out[32]: True
        ```

1. Reasons for using comprehensions.

  2. More declarative style: models `map`, `filter` and anonymous `lambda` functionality in condensed syntax.
  
  2. Efficiency (speed).

1. How do we measure speed? Timing

  2. Using `timeit` (`%timeit` in Ipython) to find the average time to run a code block.

  2. Timing differences between comprehensions and `for`-loops.


1. Generators and other forms of lazy evaluation

  2. What is constructed is not the whole sequence but an object that can produce the sequence bit by bit as needed. Compare the speed of constructing a list:

        ```python
        In [1]: %timeit list(range(10))
        1000000 loops, best of 3: 655 ns per loop
        
        In [2]: %timeit list(range(1000000))
        10 loops, best of 3: 34.7 ms per loop
        ```python

    with the speed of constructing only a generator:

        ```python
        In [3]: %timeit range(10)
        1000000 loops, best of 3: 263 ns per loop
        
        In [4]: %timeit range(1000000)
        1000000 loops, best of 3: 299 ns per loop
        ```python


[end]
